// @flow
import type {AddressedChangeset, MapKey, True, False} from '$shared/DataVerse/types'
import type {default as Tappable} from '$shared/DataVerse/utils/Tappable'
import {type DecidePointerType} from '$shared/DataVerse/derivations/pointer'

type Unboxed<O> = $FixMe // eslint-disable-line no-unused-vars
export type DictAtomChangeType<O: {}> = {overriddenRefs: $Shape<O>, deletedKeys: Array<$Keys<O>>, addedKeys: Array<$Keys<O>>}
export type DictAtomDeepChangeType<O> = AddressedChangeset & {type: 'MapChange'} & DictAtomChangeType<O>
export type DictAtomDeepDiffType<O> = AddressedChangeset & {type: 'MapDiff', deepUnboxOfOldRefs: Unboxed<O>, deepUnboxOfNewRefs: Unboxed<O>, deletedKeys: Array<$Keys<O>>}

export type IsDictAtom<V> = $ElementType<V, 'isDictAtom'>

export type IDictAtom<O: {}> = {
  isDictAtom: True,
  isBoxAtom: False,
  isArrayAtom: False,
  isAtom: True,
  isCompositeAtom: True,
  isPointer: False,

  _internalMap: O,
  setProp<K: $Keys<O>, V: $ElementType<O, K>>(key: K, value: V): IDictAtom<O>,
  prop<K: $Keys<O>>(key: K): $ElementType<O, K>,
  deleteProp<K: $Keys<O>>(key: K): IDictAtom<O>,

  deepChanges(): Tappable<$FixMe>,
  deepDiffs(): Tappable<$FixMe>,

  changes(): Tappable<DictAtomChangeType<O>>,
  forEach: <K: $Keys<O>>(fn: ($ElementType<O, K>, K) => void | false) => void,
  keys(): Array<$Keys<O>>,
  derivedDict(): $FixMe,
  pointer(): DecidePointerType<IDictAtom<O>>,

  _setParent(p: $FixMe, key: MapKey): void,
  _unsetParent(): void,
  getParent(): ?$FixMe,
}

declare function dict<O: {}>(O): IDictAtom<O>

export default dict

declare var DictAtom: $FixMe

export {DictAtom}